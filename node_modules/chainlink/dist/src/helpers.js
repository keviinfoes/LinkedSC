"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const cbor_1 = __importDefault(require("cbor"));
const truffle_contract_1 = __importDefault(require("truffle-contract"));
const LinkToken_json_1 = __importDefault(require("./LinkToken.json"));
const matchers_1 = require("./matchers");
const abi = __importStar(require("ethereumjs-abi"));
const bn_js_1 = __importDefault(require("bn.js"));
const util = __importStar(require("ethereumjs-util"));
const HEX_BASE = 16;
web3.providers.HttpProvider.prototype.sendAsync =
    web3.providers.HttpProvider.prototype.send;
exports.eth = web3.eth;
/**
 * Generate roles and personas for tests along with their corrolated account addresses
 */
async function initializeRolesAndPersonas() {
    const [defaultAccount, oracleNode1, oracleNode2, oracleNode3, stranger, consumer,] = await exports.eth.getAccounts();
    const personas = {
        Default: defaultAccount,
        Neil: oracleNode1,
        Ned: oracleNode2,
        Nelly: oracleNode3,
        Carol: consumer,
        Eddy: stranger,
    };
    const roles = {
        defaultAccount,
        oracleNode: oracleNode1,
        oracleNode1,
        oracleNode2,
        oracleNode3,
        stranger,
        consumer,
    };
    return { personas, roles };
}
exports.initializeRolesAndPersonas = initializeRolesAndPersonas;
const bNToStringOrIdentity = (a) => (bn_js_1.default.isBN(a) ? a.toString() : a);
// Deal with transfer amount type truffle doesn't currently handle. (BN)
exports.wrappedERC20 = (contract) => ({
    ...contract,
    transfer: async (address, amount) => contract.transfer(address, bNToStringOrIdentity(amount)),
    transferAndCall: async (address, amount, payload, options) => contract.transferAndCall(address, bNToStringOrIdentity(amount), payload, options),
});
exports.linkContract = async (account) => {
    if (!account) {
        throw Error('No account supplied as a parameter');
    }
    const receipt = await web3.eth.sendTransaction({
        data: LinkToken_json_1.default.bytecode,
        from: account,
        gas: 2000000,
    });
    const contract = truffle_contract_1.default({ abi: LinkToken_json_1.default.abi });
    contract.setProvider(web3.currentProvider);
    contract.defaults({
        from: account,
        gas: 3500000,
        gasPrice: 10000000000,
    });
    return exports.wrappedERC20(await contract.at(receipt.contractAddress));
};
exports.bigNum = (num) => web3.utils.toBN(num);
// TODO: dont call assertions on import
matchers_1.assertBigNum(exports.bigNum('1'), exports.bigNum(1), 'Different representations should give same BNs');
// toWei(n) is n * 10**18, as a BN.
exports.toWei = (num) => exports.bigNum(web3.utils.toWei(exports.bigNum(num)));
// TODO: dont call assertions on import
matchers_1.assertBigNum(exports.toWei('1'), exports.toWei(1), 'Different representations should give same BNs');
exports.toUtf8 = web3.utils.toUtf8;
exports.keccak = web3.utils.sha3;
exports.hexToInt = (str) => exports.bigNum(str).toNumber();
exports.toHexWithoutPrefix = (arg) => {
    if (arg instanceof Buffer || arg instanceof bn_js_1.default) {
        return arg.toString('hex');
    }
    else if (arg instanceof Uint8Array) {
        return arg.reduce((a, v) => a + v.toString(16).padStart(2, '0'), '');
    }
    else if (Number(arg) === arg) {
        return arg.toString(16).padStart(64, '0');
    }
    else {
        return Buffer.from(arg, 'ascii').toString('hex');
    }
};
exports.toHex = (value) => {
    return Ox(exports.toHexWithoutPrefix(value));
};
function Ox(value) {
    return value.slice(0, 2) !== '0x' ? `0x${value}` : value;
}
exports.Ox = Ox;
// True if h is a standard representation of a byte array, false otherwise
exports.isByteRepresentation = (h) => {
    return h instanceof Buffer || h instanceof bn_js_1.default || h instanceof Uint8Array;
};
exports.getEvents = (contract) => new Promise((resolve, reject) => contract
    .getPastEvents()
    .then((events) => resolve(events))
    .catch((error) => reject(error)));
exports.getLatestEvent = async (contract) => {
    const events = await exports.getEvents(contract);
    return events[events.length - 1];
};
// link param must be from linkContract(), if amount is a BN
exports.requestDataFrom = (oc, link, amount, args, options) => {
    if (!options) {
        options = { value: 0 };
    }
    return link.transferAndCall(oc.address, amount, args, options);
};
exports.functionSelector = (signature) => '0x' +
    exports.keccak(signature)
        .slice(2)
        .slice(0, 8);
exports.assertActionThrows = (action) => Promise.resolve()
    .then(action)
    .catch(error => {
    assert(error, 'Expected an error to be raised');
    assert(error.message, 'Expected an error to be raised');
    return error.message;
})
    .then(errorMessage => {
    assert(errorMessage, 'Expected an error to be raised');
    const invalidOpcode = errorMessage.includes('invalid opcode');
    const reverted = errorMessage.includes('VM Exception while processing transaction: revert');
    assert(invalidOpcode || reverted, 'expected following error message to include "invalid JUMP" or ' +
        `"revert": "${errorMessage}"`);
    // see https://github.com/ethereumjs/testrpc/issues/39
    // for why the "invalid JUMP" is the throw related error when using TestRPC
});
exports.checkPublicABI = (contract, expectedPublic) => {
    const actualPublic = [];
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for (const method of contract.abi) {
        if (method.type === 'function') {
            actualPublic.push(method.name);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for (const method of actualPublic) {
        const index = expectedPublic.indexOf(method);
        assert.isAtLeast(index, 0, `#${method} is NOT expected to be public`);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    for (const method of expectedPublic) {
        const index = actualPublic.indexOf(method);
        assert.isAtLeast(index, 0, `#${method} is expected to be public`);
    }
};
exports.decodeRunABI = (log) => {
    const runABI = util.toBuffer(log.data);
    const types = ['bytes32', 'address', 'bytes4', 'bytes'];
    return abi.rawDecode(types, runABI);
};
const startMapBuffer = Buffer.from([0xbf]);
const endMapBuffer = Buffer.from([0xff]);
exports.decodeRunRequest = (log) => {
    const runABI = util.toBuffer(log.data);
    const types = [
        'address',
        'bytes32',
        'uint256',
        'address',
        'bytes4',
        'uint256',
        'uint256',
        'bytes',
    ];
    const [requester, requestId, payment, callbackAddress, callbackFunc, expiration, version, data,] = abi.rawDecode(types, runABI);
    return {
        callbackAddr: Ox(callbackAddress),
        callbackFunc: exports.toHex(callbackFunc),
        data: autoAddMapDelimiters(data),
        dataVersion: version,
        expiration: exports.toHex(expiration),
        id: exports.toHex(requestId),
        jobId: log.topics[1],
        payment: exports.toHex(payment),
        requester: Ox(requester),
        topic: log.topics[0],
    };
};
function autoAddMapDelimiters(data) {
    let buffer = data;
    if (buffer[0] >> 5 !== 5) {
        buffer = Buffer.concat([startMapBuffer, buffer, endMapBuffer], buffer.length + 2);
    }
    return buffer;
}
exports.decodeDietCBOR = (data) => {
    return cbor_1.default.decodeFirstSync(autoAddMapDelimiters(data));
};
exports.runRequestId = (log) => {
    const { requestId } = exports.decodeRunRequest(log);
    return requestId;
};
exports.requestDataBytes = (specId, to, fHash, nonce, data) => {
    const types = [
        'address',
        'uint256',
        'bytes32',
        'address',
        'bytes4',
        'uint256',
        'uint256',
        'bytes',
    ];
    const values = [0, 0, specId, to, fHash, nonce, 1, data];
    const encoded = abiEncode(types, values);
    const funcSelector = exports.functionSelector('oracleRequest(address,uint256,bytes32,address,bytes4,uint256,uint256,bytes)');
    return funcSelector + encoded;
};
function abiEncode(types, values) {
    return abi.rawEncode(types, values).toString('hex');
}
exports.abiEncode = abiEncode;
exports.newUint8ArrayFromStr = (str) => {
    const codePoints = [...str].map(c => c.charCodeAt(0));
    return Uint8Array.from(codePoints);
};
// newUint8Array returns a uint8array of count bytes from either a hex or
// decimal string, hex strings must begin with 0x
exports.newUint8Array = (str, count) => {
    let result = new Uint8Array(count);
    if (str.startsWith('0x') || str.startsWith('0X')) {
        const hexStr = str.slice(2).padStart(count * 2, '0');
        for (let i = result.length; i >= 0; i--) {
            const offset = i * 2;
            result[i] = parseInt(hexStr[offset] + hexStr[offset + 1], HEX_BASE);
        }
    }
    else {
        const num = exports.bigNum(str);
        result = newHash('0x' + num.toString(HEX_BASE));
    }
    return result;
};
// newSignature returns a signature object with v, r, and s broken up
exports.newSignature = (str) => {
    const oracleSignature = exports.newUint8Array(str, 65);
    let v = oracleSignature[64];
    if (v < 27) {
        v += 27;
    }
    return {
        full: oracleSignature,
        r: oracleSignature.slice(0, 32),
        s: oracleSignature.slice(32, 64),
        v,
    };
};
// newHash returns a 65 byte Uint8Array for representing a hash
function newHash(str) {
    return exports.newUint8Array(str, 32);
}
exports.newHash = newHash;
// newAddress returns a 20 byte Uint8Array for representing an address
exports.newAddress = (str) => {
    return exports.newUint8Array(str, 20);
};
// lengthTypedArrays sums the length of all specified TypedArrays
exports.lengthTypedArrays = (...arrays) => {
    return arrays.reduce((a, v) => a + v.length, 0);
};
exports.toBuffer = (uint8a) => {
    return Buffer.from(uint8a);
};
// concatTypedArrays recursively concatenates TypedArrays into one big
// TypedArray
// TODO: Does not work recursively
exports.concatTypedArrays = (...arrays) => {
    const size = exports.lengthTypedArrays(...arrays);
    const arrayCtor = arrays[0].constructor;
    const result = new arrayCtor(size);
    let offset = 0;
    arrays.forEach(a => {
        result.set(a, offset);
        offset += a.length;
    });
    return result;
};
exports.increaseTime5Minutes = async () => {
    await web3.currentProvider.send({
        id: 0,
        jsonrpc: '2.0',
        method: 'evm_increaseTime',
        params: [300],
    }, (error) => {
        if (error) {
            console.log(`Error during helpers.increaseTime5Minutes! ${error}`);
            throw error;
        }
    });
};
exports.sendToEvm = async (evmMethod, ...params) => {
    await web3.currentProvider.send({
        id: 0,
        jsonrpc: '2.0',
        method: evmMethod,
        params: [...params],
    }, (error) => {
        if (error) {
            console.log(`Error during ${evmMethod}! ${error}`);
            throw error;
        }
    });
};
exports.mineBlocks = async (blocks) => {
    for (let i = 0; i < blocks; i++) {
        await exports.sendToEvm('evm_mine');
    }
};
exports.createTxData = (selector, types, values) => {
    const funcSelector = exports.functionSelector(selector);
    const encoded = abiEncode([...types], [...values]);
    return funcSelector + encoded;
};
exports.calculateSAID = ({ payment, expiration, endAt, oracles, requestDigest, }) => {
    const serviceAgreementIDInput = exports.concatTypedArrays(newHash(payment.toString()), newHash(expiration.toString()), newHash(endAt.toString()), exports.concatTypedArrays(...oracles
        .map(exports.newAddress)
        .map(exports.toHex)
        .map(newHash)), requestDigest);
    const serviceAgreementIDInputDigest = util.keccak(exports.toHex(serviceAgreementIDInput));
    return newHash(exports.toHex(serviceAgreementIDInputDigest));
};
exports.recoverPersonalSignature = (message, signature) => {
    const personalSignPrefix = exports.newUint8ArrayFromStr('\x19Ethereum Signed Message:\n');
    const personalSignMessage = Uint8Array.from(exports.concatTypedArrays(personalSignPrefix, exports.newUint8ArrayFromStr(message.length.toString()), message));
    const digest = util.keccak(exports.toBuffer(personalSignMessage));
    const requestDigestPubKey = util.ecrecover(digest, signature.v, exports.toBuffer(signature.r), exports.toBuffer(signature.s));
    return util.pubToAddress(requestDigestPubKey);
};
exports.personalSign = async (account, message) => {
    if (!exports.isByteRepresentation(message)) {
        throw new Error(`Message ${message} is not a recognized representation of a byte array.
    (Can be Buffer, BigNumber, Uint8Array, 0x-prepended hexadecimal string.)`);
    }
    return exports.newSignature(await web3.eth.sign(exports.toHex(message), account));
};
exports.executeServiceAgreementBytes = (sAID, to, fHash, nonce, data) => {
    const types = [
        'address',
        'uint256',
        'bytes32',
        'address',
        'bytes4',
        'uint256',
        'uint256',
        'bytes',
    ];
    const values = [0, 0, sAID, to, fHash, nonce, 1, data];
    const encoded = abiEncode(types, values);
    const funcSelector = exports.functionSelector('oracleRequest(address,uint256,bytes32,address,bytes4,uint256,uint256,bytes)');
    return funcSelector + encoded;
};
// Convenience functions for constructing hexadecimal representations of
// binary serializations.
exports.strip0x = (s) => s.startsWith('0x') ? s.slice(2) : s;
exports.padHexTo256Bit = (s) => exports.strip0x(s).padStart(64, '0');
exports.padNumTo256Bit = (n) => exports.padHexTo256Bit(n.toString(16));
exports.constructStructArgs = (fieldNames, values) => {
    assert.equal(fieldNames.length, values.length);
    const args = {};
    for (let i = 0; i < fieldNames.length; i++) {
        args[i] = values[i];
        args[fieldNames[i]] = values[i];
    }
    return args;
};
exports.initiateServiceAgreementArgs = ({ payment, expiration, endAt, oracles, oracleSignatures, requestDigest, }) => {
    return [
        exports.constructStructArgs(['payment', 'expiration', 'endAt', 'oracles', 'requestDigest'], [
            exports.toHex(newHash(payment.toString())),
            exports.toHex(newHash(expiration.toString())),
            exports.toHex(newHash(endAt.toString())),
            oracles.map(exports.newAddress).map(exports.toHex),
            exports.toHex(requestDigest),
        ]),
        exports.constructStructArgs(['vs', 'rs', 'ss'], [
            oracleSignatures.map((os) => os.v),
            oracleSignatures.map((os) => exports.toHex(os.r)),
            oracleSignatures.map((os) => exports.toHex(os.s)),
        ]),
    ];
};
// Call coordinator contract to initiate the specified service agreement, and
// get the return value
exports.initiateServiceAgreementCall = async (coordinator, args) => coordinator.initiateServiceAgreement.call(...exports.initiateServiceAgreementArgs(args));
/** Call coordinator contract to initiate the specified service agreement. */
exports.initiateServiceAgreement = async (coordinator, args) => coordinator.initiateServiceAgreement(...exports.initiateServiceAgreementArgs(args));
/** Check that the given service agreement was stored at the correct location */
exports.checkServiceAgreementPresent = async (coordinator, { payment, expiration, endAt, requestDigest, id }) => {
    const sa = await coordinator.serviceAgreements.call(id);
    matchers_1.assertBigNum(sa[0], exports.bigNum(payment));
    matchers_1.assertBigNum(sa[1], exports.bigNum(expiration));
    matchers_1.assertBigNum(sa[2], exports.bigNum(endAt));
    assert.equal(sa[3], exports.toHex(requestDigest));
    /// / TODO:
    /// / Web3.js doesn't support generating an artifact for arrays
    /// within a struct. / This means that we aren't returned the
    /// list of oracles and / can't assert on their values.
    /// /
    /// / However, we can pass them into the function to generate the
    /// ID / & solidity won't compile unless we pass the correct
    /// number and / type of params when initializing the
    /// ServiceAgreement struct, / so we have some indirect test
    /// coverage.
    /// /
    /// / https://github.com/ethereum/web3.js/issues/1241
    /// / assert.equal(
    /// /   sa[2],
    /// /   ['0x70AEc4B9CFFA7b55C0711b82DD719049d615E21d',
    /// /    '0xd26114cd6EE289AccF82350c8d8487fedB8A0C07']
    /// / )
};
// Check that all values for the struct at this SAID have default values. I.e.
// nothing was changed due to invalid request
exports.checkServiceAgreementAbsent = async (coordinator, serviceAgreementID) => {
    const sa = await coordinator.serviceAgreements.call(exports.toHex(serviceAgreementID).slice(0, 66));
    matchers_1.assertBigNum(sa[0], exports.bigNum(0));
    matchers_1.assertBigNum(sa[1], exports.bigNum(0));
    matchers_1.assertBigNum(sa[2], exports.bigNum(0));
    assert.equal(sa[3], '0x0000000000000000000000000000000000000000000000000000000000000000');
};
exports.newServiceAgreement = async (params) => {
    const agreement = {};
    params = params || {};
    agreement.payment = params.payment || '1000000000000000000';
    agreement.expiration = params.expiration || 300;
    agreement.endAt = params.endAt || sixMonthsFromNow();
    if (!params.oracles) {
        throw Error('No Oracle node address provided');
    }
    agreement.oracles = params.oracles;
    agreement.oracleSignatures = [];
    agreement.requestDigest =
        params.requestDigest ||
            newHash('0xbadc0de5badc0de5badc0de5badc0de5badc0de5badc0de5badc0de5badc0de5');
    const sAID = exports.calculateSAID(agreement);
    agreement.id = exports.toHex(sAID);
    for (let i = 0; i < agreement.oracles.length; i++) {
        const oracle = agreement.oracles[i];
        const oracleSignature = await exports.personalSign(oracle, sAID);
        const requestDigestAddr = exports.recoverPersonalSignature(sAID, oracleSignature);
        assert.equal(oracle.toLowerCase(), exports.toHex(requestDigestAddr));
        agreement.oracleSignatures[i] = oracleSignature;
    }
    return agreement;
};
function sixMonthsFromNow() {
    return Math.round(Date.now() / 1000.0) + 6 * 30 * 24 * 60 * 60;
}
exports.sixMonthsFromNow = sixMonthsFromNow;
exports.fulfillOracleRequest = async (oracle, request, response, options) => {
    if (!options) {
        options = { value: 0 };
    }
    return oracle.fulfillOracleRequest(request.id, request.payment, request.callbackAddr, request.callbackFunc, request.expiration, exports.toHex(response), options);
};
exports.cancelOracleRequest = async (oracle, request, options) => {
    if (!options) {
        options = { value: 0 };
    }
    return oracle.cancelOracleRequest(request.id, request.payment, request.callbackFunc, request.expiration, options);
};
//# sourceMappingURL=helpers.js.map